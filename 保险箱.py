# 问题描述
# 小蓝有一个保险箱，保险箱上共有位数字。
# 小蓝可以任意调整保险箱上的侮个数字，每一次操作可以将其中一位
# 增加1或减少1。
# 当某位原本为9或0时可能会向前（左边）进位退位，当最高位（左
# 边第一位)上的数字变化时向前的进位或退位忽略。
# 例如：00000的第5位减1变为99999：99999的第5位减1变
# 为99998：00000的第4位减1变为99990；97993的第4位加
# 1变为98003：99909的第3位边加1变为00009。
# 保险箱上一开始有一个数字x,小蓝希望把它变成y,这样才能打开
# 它，问小蓝最少需要操作的次数。
# 输入格式
# 输入的第一行包含一个整数n。
# 第二行包含一个n位整数x。
# 第三行包含一个n位整数y。
# 输出格式
# 输出一行包含一个整数表示答案。
import sys
n = int(input())
x = input()[::-1]
y = input()[::-1]
a = [0]
b = [0]
for i in range(n):
  a.append(int(x[i]))
  b.append(int(y[i]))
dp = [[sys.maxsize]*3 for _ in range(n+1)]
dp[1][0] = abs(a[1] - b[1])
dp[1][1] = 10 - a[1] + b[1]
dp[1][2] = 10 + a[1] - b[1]
for i in range(2,n+1):
  dp[i][0] = min(dp[i-1][0]+abs(a[i]-b[i]),dp[i-1][1]+abs(a[i]+1-b[i]),dp[i-1][2]+abs(a[i]-1-b[i]))
  dp[i][1] = min(dp[i-1][0]+10-a[i]+b[i],dp[i-1][1]+9-a[i]+b[i],dp[i-1][2]+11-a[i]+b[i])
  dp[i][2] = min(dp[i-1][0]+10+a[i]-b[i],dp[i-1][1]+11+a[i]-b[i],dp[i-1][2]+9+a[i]-b[i])
ans = min(dp[n][0],dp[n][1],dp[n][2])
print(ans)