# 题目描述
# 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的
# 路径。对于每条路径，把路径上面的数起来可以得到一个和，你的任务就是找到最大的和。
# 路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或
# 者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过1。
# 输入描述
# 输入的第一行包含一个整数N(1≤N≤100)，表示三角形的行数。
# 下面的N行给出数字三角形。数字三角形上的数都是0至100之间的整数。
# 输出描述
# 输出一个整数，表示答案。
N = int(input())
sjx = [list(map(int,input().split())) for _ in range(N)]
for i in range(1,N):
    for j in range(0,i+1):
        if j == 0:
            sjx[i][j] += sjx[i-1][j+1]
        elif j == i:
            sjx[i][j] += sjx[i-1][j-1]
        else:
            sjx[i][j] += max(sjx[i-1][j-1:j+1])
if N % 2 == 1:
    print(sjx[-1][N//2])
else:
    print(max(sjx[-1][N//2-1],sjx[-1][N//2]))

