# 问题描述
# 最近暑期特训算法班的同学们表现出色，他们的老师肖恩决定给他们
# 分发糖果。肖恩购买了几个不同种类的糖果，用小写的阿拉伯字母表
# 示。每个糖果必须分发给一个同学，并且每个同学至少要分到一个糖
# 果。同学们的开心程度定义为他们所分到的糖果组成的字符串s的
# 字典序。肖恩希望同学们的开心程度相差尽量小，因此他要找到一种
# 方案，使得所有糖果组成的字符串中字典序最大的字符串尽可能小。
# 请输出能够实现字典序最小可能的mx(s[1],s[2],s[3],,s[x])。
# 输入描述
# 第一行输入两个整数n和x,分别表示有个糖果x个同学。
# 第二行输入一个长度为几的字符串S，S[2表示第i个糖果的种
# 类。
# 数据保证1≤n≤106,1≤x≤n,S[∈['a,'z]。
# 输出描述
# 输出一个字符串，为所有糖果组成的字符串中字典序最大的字符串最
# 小的可能值。
n,x = map(int,input().split())
s = list(input())
s = sorted(s)
if s[0] == s[-1]:
  if n % x == 0:
    print(s[0]*n//x)
  else:
    print(s[0]*(n//x+1))
else:
  if s[x-1] != s[0]:
    print(s[x-1])
  else:
    if s[x] == s[-1]:
      if (n-x)%x == 0:
        print(s[0]+s[x]*n//x)
      else:
        print(s[0]+s[x]*(n//x+1))
    else:
      print(s[0]+''.join(s[x:]))